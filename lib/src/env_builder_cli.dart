import 'package:universal_io/io.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';
import 'package:yaml_edit/yaml_edit.dart';
import 'package:env_builder_cli/src/env_builder.dart';

class EnvBuilderCli implements EnvBuilder {
  @override
  String envDartFileSuffix(String fileName) {
    final lower = fileName.toLowerCase();
    if (lower.contains('development')) return 'dev';
    if (lower.contains('production')) return 'prod';
    if (lower.contains('staging')) return 'stg';
    return 'prod';
  }

  @override
  String capitalizeFirst(String input) {
    if (input.isEmpty) return input;
    return input[0].toUpperCase() + input.substring(1).toLowerCase();
  }

  @override
  String toCamelCase(String input) {
    final parts = input.toLowerCase().split('_');
    if (parts.isEmpty) return '';

    return parts.first +
        parts.skip(1).map((word) {
          if (word.isEmpty) return '';
          return word[0].toUpperCase() + word.substring(1);
        }).join();
  }

  String _partOfGFile(String suffix) {
    if (suffix.isEmpty) {
      return '''part 'env.g.dart';''';
    } else {
      return '''part 'env.$suffix.g.dart';''';
    }
  }

  @override
  String fileExporter(String suffix) {
    if (suffix.isEmpty) {
      return "export 'src/env.dart';";
    } else {
      return "export 'src/env.$suffix.dart';";
    }
  }

  String generateCommentFromKey(String key) {
    final readable = key
        .toLowerCase()
        .replaceAll('_', ' ')
        .replaceAllMapped(
          RegExp(r'\b\w'),
          (match) => match.group(0)!.toUpperCase(),
        );
    return 'The value for $readable.';
  }

  @override
  String generateEnvClassContent(
    String envFileName,
    String envClassName,
    File envFile,
  ) {
    final suffix = envDartFileSuffix(envFileName);
    final envFileRelative = p.basename(envFileName);

    // Use class suffix lowercase for referring to generated private class consts
    final privateClassName = '_$envClassName';

    final className = capitalizeFirst(suffix);

    final Map<String, String> envFileContent = parseEnvFile(envFile);
    final partOf = _partOfGFile(suffix);

    final fields = envFileContent.keys
        .map((k) {
          final keyName = toCamelCase(k);
          final comment = generateCommentFromKey(k);

          return '''
/// $comment
@EnviedField(varName: '$k', obfuscate: true)
static final String $keyName = $privateClassName.$keyName;
''';
        })
        .join('\n');

    return '''
import 'package:envied/envied.dart';

$partOf

@Envied(path: '$envFileRelative', obfuscate: true)
abstract class Env$className {
  $fields
}
''';
  }

  @override
  String generateEnvClassName(String envFileName) {
    final lower = envFileName.toLowerCase();
    if (lower.contains('development')) return 'EnvDev';
    if (lower.contains('production')) return 'EnvProd';
    if (lower.contains('staging')) return 'EnvStg';
    return 'EnvProd';
  }

  @override
  String generateEnvDartFileName(String envFileName) {
    final lower = envFileName.toLowerCase();
    if (lower.contains('development')) return 'env.dev.dart';
    if (lower.contains('production')) return 'env.prod.dart';
    if (lower.contains('staging')) return 'env.stg.dart';
    return 'env.prod.dart';
  }

  @override
  void updatePubspecYaml(File pubspecFile, String path) async {
    String content;
    if (pubspecFile.existsSync()) {
      final content = pubspecFile.readAsStringSync();

      // Charger le YAML existant
      final doc = loadYaml(content);
      final editor = YamlEditor(content);

      const newDescription =
          'A very good package generated by Env Builder CLI for environment variables';
      const newVersion = '1.0.0';

      try {
        // Si la clé description n'existe pas, on la crée
        if (doc is YamlMap && !doc.containsKey('description')) {
          editor.update(['description'], newDescription);
        } else {
          editor.update(['description'], newDescription);
        }

        if (doc is YamlMap && !doc.containsKey('version')) {
          editor.update(['version'], newVersion);
        } else {
          editor.update(['version'], newVersion);
        }

        // Écriture dans le fichier
        pubspecFile.writeAsStringSync(editor.toString());
        print('pubspec.yaml updated with new description.');
      } catch (e) {
        print('Failed to update pubspec.yaml: $e');
      }
      // pubspecFile.writeAsStringSync(editor.toString());
      await flutterCommand(
        ['pub', 'add', 'envied'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['pub', 'add', 'envied_generator', '--dev'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['pub', 'add', 'build_runner', '--dev'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['run', 'build_runner', 'build'],
        path: path,
        engine: 'dart',
      );
      print(
        'Updated pubspec.yaml with envied dependencies and flutter plugin platforms.',
      );
    } else {
      // Create new pubspec.yaml with required content
      content = '''
name: env
description: A very good package generated by Env Builder CLI for environment variables
version: 0.0.1
environment:
  sdk: ^3.8.1
  flutter: ">=1.17.0"

dependencies:

dev_dependencies:

''';
      pubspecFile.writeAsStringSync(content);
      await flutterCommand(
        ['pub', 'add', 'envied'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['pub', 'add', 'envied_generator', '--dev'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['pub', 'add', 'build_runner', '--dev'],
        path: path,
        engine: 'dart',
      );
      await flutterCommand(
        ['run', 'build_runner', 'build'],
        path: path,
        engine: 'dart',
      );

      print(
        'Created pubspec.yaml with envied dependencies and flutter plugin platforms.',
      );
    }
  }

  @override
  void updateRootPubspecWithEnvPackage(String rootPubspecPath) {
    final file = File(rootPubspecPath);
    if (!file.existsSync()) {
      print('Error: root pubspec.yaml not found at $rootPubspecPath!');
      exit(1);
    }

    final originalYaml = file.readAsStringSync();
    final doc = loadYaml(originalYaml);
    final editor = YamlEditor(originalYaml);

    final Map? dependencies = (doc as Map?)?['dependencies'] as Map?;

    if (dependencies == null) {
      // dependencies section missing, add whole dependencies block
      editor.update(
        ['dependencies'],
        {
          'env': {'path': 'packages/env'},
        },
      );
      file.writeAsStringSync(editor.toString());
      print(
        'Added env package as a path dependency to root pubspec.yaml (dependencies section added).',
      );
      return;
    }

    if (!dependencies.containsKey('env')) {
      editor.update(['dependencies', 'env'], {'path': 'packages/env'});
      file.writeAsStringSync(editor.toString());
      print('Added env package as a path dependency to root pubspec.yaml.');
    } else {
      // Dependency already exists
      print('env package dependency already exists in root pubspec.yaml.');
    }
  }

  @override
  void printUsage() {
    print('''
Usage:
  dart run env_builder_cli.dart --env-file=.env.development,.env.production,.env.staging

Description:
  Automates creation or update of the env Flutter package inside packages/env 
  by copying specified .env files, generating Dart code with Envied, 
  updating dependencies, and running flutter pub get automatically.
''');
  }

  @override
  Map<String, String> parseEnvFile(File file) {
    final Map<String, String> envVars = {};

    final lines = file.readAsLinesSync();
    for (final line in lines) {
      final trimmed = line.trim();

      if (trimmed.isEmpty || trimmed.startsWith('#')) continue;

      final index = trimmed.indexOf('=');
      if (index == -1) continue;

      final key = trimmed.substring(0, index).trim();
      var value = trimmed.substring(index + 1).trim();

      // Remove optional quotes (single or double)
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.substring(1, value.length - 1);
      }

      envVars[key] = value;
    }

    return envVars;
  }

  @override
  Future<void> createGitignoreWithEnvEntries({
    String path = '.gitignore',
    bool includeFlutterDefaults = true,
    bool keepExample = true,
  }) async {
    final file = File(path);
    final exists = file.existsSync();

    final flutterIgnore = '''
# Dart & Flutter
.dart_tool/
.packages
.pub-cache/
build/
coverage/

# VS Code
.vscode/

# IntelliJ / Android Studio
*.iml
.idea/
*.iws
*.ipr
*.bak

# Logs and locks
*.log
*.lock
pubspec.lock
''';

    final envIgnore =
        '''
# Env files (do not commit secrets)
.env
.env.*
${keepExample ? '!.env.example' : ''}
''';

    final content = StringBuffer();

    if (includeFlutterDefaults) {
      content.writeln(flutterIgnore.trim());
      content.writeln();
    }

    content.writeln(envIgnore.trim());

    if (exists) {
      final existingContent = await file.readAsString();
      if (!existingContent.contains('.env')) {
        await file.writeAsString(
          '\n${content.toString()}',
          mode: FileMode.append,
        );
        print('Appended .env rules to existing .gitignore');
      } else {
        print('.gitignore already contains .env rules.');
      }
    } else {
      await file.writeAsString(content.toString());
      print('Created .gitignore with Dart/Flutter and .env rules.');
    }
  }

  @override
  Future<ProcessResult> flutterCommand(
    List<String> arguments, {
    String? path,
    String engine = 'flutter',
  }) async {
    return await Process.run(
      engine,
      arguments,
      workingDirectory: path,
      runInShell: true,
    );
  }

  @override
  String generateEnumClassContent(File file) {
    final Map<String, String> envFileContent = parseEnvFile(file);

    final fields = envFileContent.keys
        .map((key) {
          final keyName = toCamelCase(key);
          final comment = generateCommentFromKey(key);

          return '''
  /// $comment
  $keyName('$key'),
''';
        })
        .join('\n')
        .replaceFirst(RegExp(r',\s*$'), '');

    return '''
/// {@template env}
/// A Very Good Package generated by Env Builder CLI.
/// {@endtemplate}
enum Env {

  $fields;

  /// {@macro env}
  const Env(this.name);

  /// The value of the enum class
  final String name;
}

/// Env value signature that can be used to get an environment value, base
/// on provided [Env].
typedef EnvValue = String Function(Env env);
''';
  }

  @override
  String generateAppFlavorContent(List<String> paths) {
    final flavors = paths.map((path) => getFlavor(path)).join(', ');

    final envContents = parseEnvFile(File(paths.first));

    final getEnvContent = envContents.keys
        .map((key) {
          final keyName = toCamelCase(key);

          final fields = flavors
              .split(', ')
              .map((e) {
                return '''
Flavor.$e => ${generateEnvClassName(e)}.$keyName,
''';
              })
              .join('\n');

          return '''
Env.$keyName => switch(flavor){
  $fields
},
''';
        })
        .join('\n');

    final factories = flavors
        .split(', ')
        .map((flavor) {
          return '''
factory AppFlavor.$flavor() => const AppFlavor._(flavor: Flavor.$flavor);
''';
        })
        .join('\n');

    return '''
import 'package:env/env.dart';

enum Flavor { $flavors }

sealed class AppEnv {
  const AppEnv();

  String getEnv(Env env);
}

class AppFlavor extends AppEnv {
  $factories

  const AppFlavor._({required this.flavor});

  final Flavor flavor;

  @override
  String getEnv(Env env) => switch(env){
    $getEnvContent
  };
}
''';
  }

  @override
  String getFlavor(String fileName) {
    final lower = fileName.toLowerCase();
    if (lower.contains('development')) return 'development';
    if (lower.contains('production')) return 'production';
    if (lower.contains('staging')) return 'staging';
    return 'production';
  }

  @override
  void writeEnvTestFile(String path) {
    final testDir = Directory(p.join(path, 'test'));
    final testFile = File(p.join(testDir.path, 'env_test.dart'));

    const testContent = '''
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('Env', () {
    test('can be instantiated', () {
    });
  });
}
''';

    try {
      if (!testDir.existsSync()) {
        testDir.createSync(recursive: true);
      }

      testFile.writeAsStringSync(testContent);
      print('env_test.dart file created/updated at ${testFile.path}');
    } catch (e) {
      print('Error writing env_test.dart file: $e');
      exit(1);
    }
  }
}
